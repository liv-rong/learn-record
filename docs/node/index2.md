# 解释 JavaScript 中的事件循环机制，并说明宏任务与微任务的区别。

## 同步代码：立即执行的代码，就像咖啡店里顾客直接点单

- 宏任务：较大的异步任务（setTimeout, setInterval）
- 微任务：较小的异步任务（Promise 回调, MutationObserver）

事件循环

- 执行所有同步代码
- 执行所有微任务（直到微任务队列清空）
- 执行一个宏任务（如果有的话）
- 更新 UI 渲染（浏览器）

重复步骤 1

# 如何实现一个深拷贝函数？需要考虑哪些边界情况？

# React 中 useEffect 和 useLayoutEffect 有什么区别？应该在什么场景下使用？

- useLayoutEffect 在 DOM 更新之后，浏览器绘制之前同步执行 会阻塞浏览器渲染

# 系统化性能优化方案：

## 1. 网络优化

- HTTP/2 + 域名分片
- 资源压缩（Brotli > Gzip）
- 资源预加载（preload, prefetch）
- CDN 分发静态资源
- 服务端渲染/静态站点生成

## 2. 渲染优化

- 减少重绘和回流
- 图片懒加载

## 3. js 优化

- 代码分割（Code Splitting）
- Tree Shaking（ES 模块）
- Web Workers 处理 CPU 密集型任务
- 防抖/节流频繁触发的事件

# React Fiber 架构及其解决的问题

- 增量渲染：将渲染工作拆分成多个小任务
- 任务优先级：区分高优先级（用户交互）和低优先级任务
- 并发模式：实现可中断的渲染过程
- 解决卡顿：避免大型应用中的界面卡顿问题

# React Native 的桥接机制及其性能影响

工作原理：

JavaScript 线程运行业务逻辑
原生线程（UI 线程）处理界面渲染
通过异步序列化消息进行通信
性能影响：

频繁跨桥通信会导致性能瓶颈
大量小消息比少量大消息更慢
动画和手势需要特殊优化（使用原生驱动）

# React Native 内存泄漏

未清除的订阅/事件监听器
未取消的定时器
闭包保留组件引用
原生模块未正确释放
